# Algorithms

## Overview
알고리즘은 문제를 단계별로 해결하는 절차와 방법
효율적인 설계는 프로그램 성능 개선과 문제 해결에 도움됨

## What is an Algorithm?
알고리즘은 문제 해결을 위한 명확하고 순차적인 단계와 규칙
입력 데이터를 받아 처리하여 원하는 결과를 산출하는 절차
종료 조건이 있고, 효율적이어야 함

---

## 1. 재귀 (Recursion)

### 개념
재귀는 함수가 자기 자신을 호출하는 프로그래밍 기법
복잡한 문제를 같은 유형의 작은 문제로 나누어 해결할 때 유용
분할 정복, DFS, 백트래킹 등 고급 알고리즘의 근본적인 사고방식

### 기본 구조
- 기본 사례: 재귀 종료 조건. 무한 호출 방지 목적
- 재귀 사례: 함수가 자기 자신을 다시 호출하여 문제를 해결하는 부분

### 예시 1: 팩토리얼 (n!)

```java
public class Factorial {
    public static int factorial(int n) {
        if (n == 0) return 1; // 기본 사례 (재귀 종료 조건)
        return n * factorial(n - 1); // 재귀 사례 (자기 자신 호출)
    }
}
```

### 예시 2: 피보나치 수열 (재귀 버전)

```java
public class Fibonacci {
    public static int fib(int n) {
        if (n < 2) return n;  // 기본 사례 (F(0)=0, F(1)=1)
        return fib(n - 1) + fib(n - 2); // 재귀 사례
    }
}
```

### 중요 개념: 스택 메모리 구조
재귀 함수 호출 시, 각 호출은 호출 스택 (Call Stack)에 쌓임
기본 사례에 도달하면 호출이 역순으로 종료되면서 스택에서 해제됨

---

## 2. 선형 탐색 (Linear Search)

### 개념
선형 탐색은 배열의 처음부터 끝까지 원소를 하나씩 순차적으로 비교해 원하는 값을 찾는 가장 단순한 탐색 알고리즘
데이터가 정렬되어 있지 않아도 사용 가능
* 시간 복잡도: $\text{O}(n)$

### 작동 원리
1. 배열 첫 원소부터 목표값을 찾을 때까지 하나씩 비교
2. 찾으면 해당 인덱스 반환
3. 끝까지 찾지 못하면 `-1` 반환

### 자바 예시 코드

```java
public class LinearSearch {
	public static int linearSearch(int[] arr, int target) {

		// 1. 배열의 첫 번째 요소(인덱스 0)부터 마지막 요소까지 순회 시작
		// 'i'는 현재 보고 있는 배열 요소의 위치(인덱스)를 나타냄
		for (int i = 0; i < arr.length; i++) {

			// 2. 현재 인덱스(i)의 배열 값(arr[i])이 찾으려는 값(target)과 같은지 비교
			if (arr[i] == target) {
				// 3. 만약 값이 같다면, 탐색에 성공했으므로 현재 인덱스(i)를 즉시 반환하고 메서드 종료
				return i;
			}
		}

		// 4. 반복문이 끝날 때까지 target 값을 찾지 못했다면
		// 배열 전체를 다 살펴보았다는 의미
		// 찾지 못했음을 나타내는 특정한 값인 -1을 반환
		return -1;
	}
}
```

---

## 3. 버블 정렬 (Bubble Sort)

### 개념
버블 정렬은 인접한 원소를 비교해 큰 값을 뒤로 보내면서 정렬
단순하고 정렬의 기본 개념을 이해하기 좋음
* 시간 복잡도: $\text{O}(n^2)$

#### 동작 과정 예시 (배열: $\mathbf{[5, 3, 8, 4, 2]}$)
버블 정렬은 배열의 크기가 $n$일 때, 최대 $n-1$번의 **Pass** (전체 순회)를 수행하여 정렬
매 Pass마다 정렬되지 않은 부분에서 가장 큰 값이 배열의 맨 끝(오른쪽)으로 이동하여 그 자리를 확정

| 단계 | 배열 상태 | 비교 / 교환 (${>}$ 이면 교환) | 정렬 완료 부분 | 설명 |
| :--- | :--- | :--- | :--- | :--- |
| **초기** | $[5, 3, 8, 4, 2]$ | | | |
| **Pass 1** | | | | 정렬되지 않은 범위: $[0, 4]$. 가장 큰 값 **8**이 오른쪽으로 이동 |
| 1.1 | $[\mathbf{5, 3}, 8, 4, 2]$ | $5 > 3 \implies$ **교환** | | |
| | $[3, 5, 8, 4, 2]$ | | | |
| 1.2 | $[3, \mathbf{5, 8}, 4, 2]$ | $5 < 8 \implies$ 교환 **X** | | |
| 1.3 | $[3, 5, \mathbf{8, 4}, 2]$ | $8 > 4 \implies$ **교환** | | |
| | $[3, 5, 4, 8, 2]$ | | | |
| 1.4 | $[3, 5, 4, \mathbf{8, 2}]$ | $8 > 2 \implies$ **교환** | | |
| **Pass 1 결과** | $\mathbf{[3, 5, 4, 2, {8}]}$ | | $\{{8}\}$ | 가장 큰 값 **8**이 최종 위치 확정 |
| **Pass 2** | | | | 정렬되지 않은 범위: $[0, 3]$. 가장 큰 값 **5**가 오른쪽으로 이동 |
| 2.1 | $[\mathbf{3, 5}, 4, 2, 8]$ | $3 < 5 \implies$ 교환 **X** | | |
| 2.2 | $[3, \mathbf{5, 4}, 2, 8]$ | $5 > 4 \implies$ **교환** | | |
| | $[3, 4, 5, 2, 8]$ | | | |
| 2.3 | $[3, 4, \mathbf{5, 2}, 8]$ | $5 > 2 \implies$ **교환** | | |
| **Pass 2 결과** | $\mathbf{[3, 4, 2, {5}, 8]}$ | | $\{{5}, 8\}$ | **5**가 최종 위치 확정 |
| **Pass 3** | | | | 정렬되지 않은 범위: $[0, 2]$. 가장 큰 값 **4**가 오른쪽으로 이동 |
| 3.1 | $[\mathbf{3, 4}, 2, 5, 8]$ | $3 < 4 \implies$ 교환 **X** | | |
| 3.2 | $[3, \mathbf{4, 2}, 5, 8]$ | $4 > 2 \implies$ **교환** | | |
| **Pass 3 결과** | $\mathbf{[3, 2, {4}, 5, 8]}$ | | $\{{4}, 5, 8\}$ | **4**가 최종 위치 확정 |
| **Pass 4** | | | | 정렬되지 않은 범위: $[0, 1]$. 마지막으로 **3**과 **2**를 비교 |
| 4.1 | $[\mathbf{3, 2}, 4, 5, 8]$ | $3 > 2 \implies$ **교환** | | |
| **Pass 4 결과** | $\mathbf{[{2, 3}, 4, 5, 8]}$ | | $\{{2}, {3}, 4, 5, 8\}$ | **2**와 **3**이 최종 위치 확정 |
| **최종** | $\mathbf{[2, 3, 4, 5, 8]}$ | | | **정렬 완료\!** |

```java
public class BubbleSort {
	public static void bubbleSort(int[] arr) {
		// 배열의 길이(전체 요소의 개수)를 저장
		int n = arr.length;

		// 1. 외부 반복문: 정렬을 몇 번 반복할지 결정
		// 배열의 크기(n)만큼 반복하면 정렬이 완료되므로, n-1번 반복
		// 매 반복마다 가장 큰 값이 배열의 맨 뒤로 확정됨 (정렬 범위가 하나씩 줄어듦)
		for (int i = 0; i < n - 1; i++) {

			// 2. 내부 반복문: 인접한 두 요소를 비교하고 교환하는 실제 작업 수행
			// 정렬이 완료된 맨 뒤의 요소들(i개)은 다시 비교할 필요가 없으므로 범위를 줄임
			// 'n - 1 - i'는 아직 정렬되지 않은 부분까지만 순회하겠다는 뜻
			for (int j = 0; j < n - 1 - i; j++) {

				// 3. 인접한 두 요소(arr[j]와 arr[j+1])를 비교
				// 만약 현재 요소(arr[j])가 다음 요소(arr[j+1])보다 크다면, 순서가 잘못된 것
				if (arr[j] > arr[j + 1]) {

					// 4. 두 요소의 위치를 교환 (Swap)
					// 임시 변수(temp)를 사용하여 arr[j] 값을 잠시 보관
					int temp = arr[j];

					// arr[j] 자리에 더 작은 값(arr[j+1])을 넣음
					arr[j] = arr[j + 1];

					// arr[j+1] 자리에 원래 arr[j]였던 큰 값(temp)을 넣음
					arr[j + 1] = temp;
				}
				// 이 과정을 반복하며 가장 큰 값이 배열의 오른쪽 끝으로 이동함
			}
		}
	}
}
```

---

## 4. 선택 정렬 (Selection Sort)

### 개념
선택 정렬은 배열에서 최솟값을 찾아 맨 앞 요소와 교체하며 정렬
버블 정렬보다 비교 횟수는 적음
* 시간 복잡도: $\text{O}(n^2)$

### 동작 과정 예시 (배열: $\mathbf{[5, 3, 8, 4, 2]}$)

선택 정렬은 매 **Pass (외부 반복)** 마다 **정렬되지 않은 부분**에서 가장 작은 원소를 **선택**하여, 
정렬된 부분의 맨 앞으로 이동시켜 그 자리를 확정

| Pass (i) | 배열 상태 | 최솟값 탐색 범위 | 찾은 최솟값 | 교환 위치 | 정렬 완료 부분 | 설명 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **초기** | $[5, 3, 8, 4, 2]$ | | | | | |
| **Pass 1** (i=0) | $[\mathbf{5}, 3, 8, 4, 2]$ | $[5, 3, 8, 4, 2]$ | $\mathbf{2}$ (Index 4) | $5 \leftrightarrow 2$ | | Index 0 자리에 **2**를 선택하여 확정 |
| **Pass 1 결과** | $[{2}, 3, 8, 4, 5]$ | | | | $\{{2}\}$ | **2** 위치 확정 |
| **Pass 2** (i=1) | $[2, \mathbf{3}, 8, 4, 5]$ | $[3, 8, 4, 5]$ | $\mathbf{3}$ (Index 1) | $3 \leftrightarrow 3$ (교환 **X**) | | Index 1 자리에 **3**을 선택하여 확정 |
| **Pass 2 결과** | $[{2, 3}, 8, 4, 5]$ | | | | $\{{2, 3}\}$ | **3** 위치 확정 |
| **Pass 3** (i=2) | $[2, 3, \mathbf{8}, 4, 5]$ | $[8, 4, 5]$ | $\mathbf{4}$ (Index 3) | $8 \leftrightarrow 4$ | | Index 2 자리에 **4**를 선택하여 확정 |
| **Pass 3 결과** | $[{2, 3, 4}, 8, 5]$ | | | | $\{{2, 3, 4}\}$ | **4** 위치 확정 |
| **Pass 4** (i=3) | $[2, 3, 4, \mathbf{8}, 5]$ | $[8, 5]$ | $\mathbf{5}$ (Index 4) | $8 \leftrightarrow 5$ | | Index 3 자리에 **5**를 선택하여 확정 |
| **Pass 4 결과** | $[{2, 3, 4, 5}, 8]$ | | | | $\{{2, 3, 4, 5}\}$ | **5** 위치 확정 |
| **최종** | $\mathbf{[2, 3, 4, 5, 8]}$ | | | | | 정렬 완료 |


```java
public class SelectionSort {
	public static void selectionSort(int[] arr) {
		// 배열의 길이(전체 요소의 개수)를 저장
		int n = arr.length;

		// 1. 외부 반복문: 배열의 앞에서부터 하나씩 정렬된 위치를 확정
		// 마지막 요소는 자동으로 정렬되므로 n-1번까지만 반복
		for (int i = 0; i < n - 1; i++) {

			// 2. 현재 정렬하려는 위치(i)를 가장 작은 값이 있는 위치라고 가정하고 시작
			int minIdx = i;

			// 3. 내부 반복문: 정렬되지 않은 나머지 부분(i+1부터 끝까지)에서 실제 최솟값을 탐색
			for (int j = i + 1; j < n; j++) {

				// 4. 현재까지 찾은 최솟값(arr[minIdx])과 배열의 다음 값(arr[j])을 비교
				if (arr[j] < arr[minIdx]) {
					// 5. 만약 arr[j]가 더 작다면, 최솟값의 위치(minIdx)를 j로 업데이트
					minIdx = j;
				}
			}

			// 6. 탐색이 끝나면, 현재 위치(i)와 찾은 최솟값의 위치(minIdx)를 교환 (Swap)
			// 즉, 가장 작은 값을 정렬되지 않은 부분의 맨 앞(i)으로 가져옴

			// 임시 변수(temp)를 사용하여 최솟값(arr[minIdx])을 잠시 보관
			int temp = arr[minIdx];

			// 최솟값이 있던 자리(minIdx)에 원래 arr[i] 값 삽입
			arr[minIdx] = arr[i];

			// 현재 정렬 위치(arr[i])에 실제 최솟값(temp) 삽입
			arr[i] = temp;
		}
	}
}
```

---

## 5. 삽입 정렬 (Insertion Sort)

### 개념
삽입 정렬은 정렬된 부분 리스트에 새 원소를 적절히 삽입하며 정렬 과정을 수행
데이터가 거의 정렬된 상태에서 효율적
* 시간 복잡도: $\text{O}(n^2)$

### 동작 과정 예시 (배열: $\mathbf{[5, 3, 8, 4, 2]}$)

삽입 정렬은 두 번째 원소 (Index 1)부터 시작하여, 
현재 원소 (**Key**)를 정렬된 부분의 요소들과 비교하며 한 칸씩 오른쪽으로 밀어내고 (Shift), 
Key가 들어갈 올바른 위치를 찾은 후 삽입

| 단계 (i) | Key | 배열 상태                          | 비교 (Key와 정렬된 요소) | Shift (오른쪽으로 밀기) | 삽입 위치 | 정렬 완료 부분 |
| :--- | :--- |:-------------------------------| :--- | :--- | :--- | :--- |
| **초기** | | $[5, 3, 8, 4, 2]$              | | | | $\{5\}$ |
| **i=1** | $\mathbf{3}$ | $[5, 3, 8, 4, 2]$              | $5 > 3$ | $5$를 Index 1로 이동 | Index 0 | **3**을 올바른 위치에 삽입 |
| **Pass 1 결과** | | $[{3, 5}, 8, 4, 2]$ | | | | $\{{3, 5}\}$ |
| **i=2** | $\mathbf{8}$ | $[3, 5, 8, 4, 2]$              | $5 < 8$ | Shift **X** | Index 2 | **8**은 이미 올바른 위치에 삽입 |
| **Pass 2 결과** | | $[{3, 5, 8}, 4, 2]$ | | | | $\{{3, 5, 8}\}$ |
| **i=3** | $\mathbf{4}$ | $[3, 5, 8, 4, 2]$              | $8 > 4$, $5 > 4$, $3 < 4$ | $8 \to$ Index 3, $5 \to$ Index 2 | Index 1 | **4**를 3과 5 사이에 삽입 |
| **Pass 3 결과** | | $[{3, 4, 5, 8}, 2]$ | | | | $\{{3, 4, 5, 8}\}$ |
| **i=4** | $\mathbf{2}$ | $[3, 4, 5, 8, 2]$              | $8 > 2$, $5 > 2$, $4 > 2$, $3 > 2$ | $8 \to 4, 5 \to 3, 4 \to 2, 3 \to 1$ | Index 0 | **2**를 맨 앞으로 삽입 |
| **Pass 4 결과** | | $[{2, 3, 4, 5, 8}]$ | | | | $\{{2, 3, 4, 5, 8}\}$ |
| **최종** | | $\mathbf{[2, 3, 4, 5, 8]}$     | | | | 정렬 완료 |

```java
public class InsertionSort {
	public static void insertionSort(int[] arr) {
		// 배열의 길이(요소의 개수)를 저장
		int n = arr.length;

		// 1. 외부 반복문: 두 번째 요소(인덱스 1)부터 시작해서 배열 끝까지 순회
		// 인덱스 0은 이미 정렬된 부분이라고 가정하고 시작함
		for(int i = 1; i < n; i++) {

			// 2. 현재 삽입할 요소를 'key' 변수에 임시로 저장
			// 이 key가 이미 정렬된 부분에 들어갈 올바른 위치를 찾게 됨
			int key = arr[i];

			// 3. 'j'는 key의 바로 왼쪽 인덱스(정렬된 부분의 마지막 요소)를 가리킴
			int j = i - 1;

			// 4. 내부 반복문 (while): key가 들어갈 위치를 찾을 때까지 정렬된 부분을 왼쪽으로 탐색
			// 조건 1: j가 0 이상이어야 함 (배열의 시작 부분까지만 탐색)
			// 조건 2: 현재 요소(arr[j])가 삽입할 값(key)보다 크다면, key가 들어갈 자리가 아님
			while(j >= 0 && arr[j] > key) {

				// 5. arr[j]가 key보다 크므로, 한 칸 오른쪽(j+1)으로 이동(밀어냄)
				// 이렇게 해야 key가 들어갈 공간이 생김
				arr[j + 1] = arr[j];

				// 6. 다음 왼쪽 요소로 이동하여 계속 비교
				j--;
			}

			// 7. while 루프가 멈추면, arr[j + 1] 자리가 key가 들어갈 올바른 위치
			// 밀어내기가 멈춘 곳(j) 바로 다음(j+1)에 key 값을 삽입
			arr[j + 1] = key;
		}
	}
}
```

---

## 6. 이진 탐색 (Binary Search)

### 개념
이진 탐색은 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 절반씩 좁혀 나가는 탐색 기법
탐색 속도가 빠름
* 시간 복잡도: $\text{O}(\log n)$

### 작동 원리
1. 중간 원소와 목표값 비교
2. 목표값이 크면 오른쪽 절반 탐색, 작으면 왼쪽 절반 탐색
3. 범위가 없어질 때까지 반복

### 자바 예시 코드

```java
public class BinarySearch {
	public static int binarySearch(int[] arr, int target) {
		// 1. 탐색 범위의 시작점(가장 왼쪽 인덱스)을 'left'로 설정
		int left = 0;

		// 2. 탐색 범위의 끝점(가장 오른쪽 인덱스)을 'right'로 설정
		int right = arr.length - 1;

		// 3. left가 right보다 작거나 같을 때까지 반복 (탐색 범위가 남아있는 동안)
		while (left <= right) {

			// 4. 탐색 범위의 '중간 인덱스(mid)'를 계산
			// (left + right) / 2 대신 이 공식을 사용하면 정수 오버플로우를 방지할 수 있음
			int mid = left + (right - left) / 2;

			// 5. 중간 값이 찾으려는 값(target)과 같은지 확인
			if (arr[mid] == target) {
				// 6. 같으면 찾았으므로 해당 인덱스를 반환하고 종료
				return mid;
			}

			// 7. 중간 값이 target보다 작은 경우 (target이 중간 값의 오른쪽에 있음)
			else if (arr[mid] < target) {
				// 8. 탐색 범위를 오른쪽 절반으로 좁힘
				// left를 mid + 1로 업데이트 (중간 값은 이미 확인했으므로 제외)
				left = mid + 1;
			}

			// 9. 중간 값이 target보다 큰 경우 (target이 중간 값의 왼쪽에 있음)
			else {
				// 10. 탐색 범위를 왼쪽 절반으로 좁힘
				// right를 mid - 1로 업데이트 (중간 값은 이미 확인했으므로 제외)
				right = mid - 1;
			}
		}

		// 11. 반복문이 끝날 때까지 target을 찾지 못했다면
		// left > right가 되어 탐색 범위가 없다는 의미
		// 찾지 못했음을 나타내는 -1을 반환
		return -1;
	}
}
```

---

## 7. 분할 정복 (Divide and Conquer)

### 개념
분할 정복은 문제를 작은 하위 문제로 나누어 각각 해결하고, 그 해답을 합쳐서 원래 문제를 해결하는 알고리즘 전략
재귀를 기반으로 함

* 분할 (Divide): 큰 문제를 작고 같은 유형의 문제로 나눔
* 정복 (Conquer): 각 하위 문제를 재귀적으로 해결
* 결합 (Combine): 하위 문제들의 결과를 합쳐 문제를 완성

### 장점
복잡한 문제를 단순 문제로 분리해 해결하므로 설계와 분석 용이
많은 효율적인 알고리즘 (퀵 정렬, 병합 정렬, 이진 탐색 등)이 이 패턴을 기반으로 함

---

## 8. 병합 정렬 (Merge Sort)

### 개념
분할 정복 알고리즘의 대표
배열을 반씩 나눠 정렬 후 병합
* 시간 복잡도: $\text{O}(n \log n)$로 안정적 성능 보장

```java
public class MergeSort {
	/**
	 * 배열을 절반씩 나누는 (분할) 역할을 수행하는 재귀 메서드
	 */
	public static void mergeSort(int[] arr, int left, int right) {
		// 배열의 시작(left)이 끝(right)보다 작을 때만 실행 (나눌 요소가 최소 2개 이상일 때)
		if(left < right) {

			// 1. 중간 지점(mid)을 계산하여 배열을 두 부분으로 나눔
			int mid = (left + right) / 2;

			// 2. 왼쪽 절반을 재귀적으로 정렬
			mergeSort(arr, left, mid);

			// 3. 오른쪽 절반을 재귀적으로 정렬
			mergeSort(arr, mid + 1, right);

			// 4. 왼쪽과 오른쪽 절반이 모두 정렬되면, 두 부분을 합치는(병합) 작업을 수행
			merge(arr, left, mid, right);
		}
	}

	/**
	 * 정렬된 두 부분 배열(왼쪽 L, 오른쪽 R)을 하나의 정렬된 배열로 합치는 (병합) 메서드
	 */
	private static void merge(int[] arr, int left, int mid, int right) {

		// 1. 왼쪽 부분 배열(L)과 오른쪽 부분 배열(R)의 크기를 계산
		int n1 = mid - left + 1; // L의 크기
		int n2 = right - mid;    // R의 크기

		// 2. 임시 배열 L과 R을 생성하여 데이터를 복사
		int[] L = new int[n1];
		int[] R = new int[n2];

		// 원본 배열 arr에서 왼쪽 부분 데이터를 L로 복사
		for(int i = 0; i < n1; i++) L[i] = arr[left + i];

		// 원본 배열 arr에서 오른쪽 부분 데이터를 R로 복사
		for(int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

		// 3. L, R 배열에서 데이터를 꺼내 원래 배열(arr)에 병합
		int i = 0, j = 0;   // i: L 배열의 인덱스, j: R 배열의 인덱스
		int k = left;       // k: arr 배열에 병합할 위치(시작점은 left)

		// L과 R 둘 중 하나라도 끝날 때까지 반복
		while(i < n1 && j < n2) {

			// L[i]와 R[j]를 비교하여 더 작은 값을 먼저 arr[k]에 넣음
			if(L[i] <= R[j]) {
				arr[k++] = L[i++]; // L[i]가 작거나 같으면 arr에 넣고 L의 인덱스를 증가
			} else {
				arr[k++] = R[j++]; // R[j]가 더 작으면 arr에 넣고 R의 인덱스를 증가
			}
		}

		// 4. 남아있는 요소들을 처리 (둘 중 한 쪽 배열만 남아있음)

		// 만약 L 배열에 남아있는 요소가 있다면, 모두 arr 뒤에 순서대로 넣음
		while(i < n1) arr[k++] = L[i++];

		// 만약 R 배열에 남아있는 요소가 있다면, 모두 arr 뒤에 순서대로 넣음
		while(j < n2) arr[k++] = R[j++];
	}
}
```

---

## 9. 퀵 정렬 (Quick Sort)

### 개념
피벗 값을 기준으로 작은 값과 큰 값으로 분할해 재귀적으로 정렬
* 시간 복잡도: 평균 $\text{O}(n \log n)$, 최악 $\text{O}(n^2)$

```java
public class QuickSort {
	/**
	 * 배열의 특정 범위(low부터 high)를 정렬하는 재귀 함수
	 */
	public static void quickSort(int[] arr, int low, int high) {
		// 정렬할 요소가 최소 2개 이상일 때만 실행 (low가 high보다 작을 때)
		if(low < high) {

			// 1. partition 함수를 호출하여 피벗을 기준으로 배열을 분할
			// pi는 피벗이 최종적으로 자리 잡은 위치(인덱스)를 반환
			int pi = partition(arr, low, high);

			// 2. 피벗의 왼쪽 부분(피벗보다 작은 값들)을 재귀적으로 다시 정렬
			quickSort(arr, low, pi - 1);

			// 3. 피벗의 오른쪽 부분(피벗보다 큰 값들)을 재귀적으로 다시 정렬
			quickSort(arr, pi + 1, high);
		}
	}

	/**
	 * 피벗을 기준으로 배열 요소를 재배치하고, 피벗의 최종 위치를 반환하는 함수 (분할 작업)
	 */
	private static int partition(int[] arr, int low, int high) {
		// 1. 배열의 가장 오른쪽 요소(high)를 피벗(기준 값)으로 선택
		int pivot = arr[high];

		// 2. 피벗보다 작은 요소들의 '경계' 또는 '가장 오른쪽 인덱스'를 나타내는 포인터 i
		// low - 1에서 시작 (아직 작은 요소가 하나도 없기 때문)
		int i = low - 1;

		// 3. low부터 high-1까지 모든 요소를 순회하며 피벗과 비교
		for(int j = low; j < high; j++) {

			// 4. 현재 요소(arr[j])가 피벗보다 작다면
			if(arr[j] < pivot) {
				// 5. 작은 요소의 경계(i)를 한 칸 증가시킴
				i++;

				// 6. arr[j]와 arr[i]의 위치를 교환(Swap)
				// arr[j]를 피벗보다 작은 값들의 영역(i) 안으로 넣는 작업
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}

		// 7. 반복문 종료 후, 피벗을 i+1 위치에 삽입하여 최종 위치 확정
		// i+1 위치는 피벗보다 작은 값들(i) 바로 다음 자리이며, 피벗보다 큰 값들의 시작 자리임
		int temp = arr[i + 1];
		arr[i + 1] = arr[high]; // 피벗 값을 i+1 위치로 이동
		arr[high] = temp;       // 원래 피벗 위치(high)에는 i+1 위치의 값(피벗보다 컸던 값)이 들어감

		// 8. 피벗의 최종 위치(i + 1)를 반환
		return i + 1;
	}
}
```

---

