# Algorithms

## Overview
알고리즘은 문제를 단계별로 해결하는 절차와 방법
효율적인 설계는 프로그램 성능 개선과 문제 해결에 도움됨

## What is an Algorithm?
알고리즘은 문제 해결을 위한 명확하고 순차적인 단계와 규칙
입력 데이터를 받아 처리하여 원하는 결과를 산출하는 절차
종료 조건이 있고, 효율적이어야 함

---

## 1. 재귀 (Recursion)

### 개념
재귀는 함수가 자기 자신을 호출하는 프로그래밍 기법
복잡한 문제를 같은 유형의 작은 문제로 나누어 해결할 때 유용
분할 정복, DFS, 백트래킹 등 고급 알고리즘의 근본적인 사고방식

### 기본 구조
- 기본 사례: 재귀 종료 조건. 무한 호출 방지 목적
- 재귀 사례: 함수가 자기 자신을 다시 호출하여 문제를 해결하는 부분

### 예시 1: 팩토리얼 (n!)

```java
public class Factorial {
    public static int factorial(int n) {
        if (n == 0) return 1; // 기본 사례 (재귀 종료 조건)
        return n * factorial(n - 1); // 재귀 사례 (자기 자신 호출)
    }
}
```

### 예시 2: 피보나치 수열 (재귀 버전)

```java
public class Fibonacci {
    public static int fib(int n) {
        if (n < 2) return n;  // 기본 사례 (F(0)=0, F(1)=1)
        return fib(n - 1) + fib(n - 2); // 재귀 사례
    }
}
```

### 중요 개념: 스택 메모리 구조
재귀 함수 호출 시, 각 호출은 호출 스택 (Call Stack)에 쌓임
기본 사례에 도달하면 호출이 역순으로 종료되면서 스택에서 해제됨

---

## 2. 선형 탐색 (Linear Search)

### 개념
선형 탐색은 배열의 처음부터 끝까지 원소를 하나씩 순차적으로 비교해 원하는 값을 찾는 가장 단순한 탐색 알고리즘
데이터가 정렬되어 있지 않아도 사용 가능
* 시간 복잡도: $\text{O}(n)$

### 작동 원리
1. 배열 첫 원소부터 목표값을 찾을 때까지 하나씩 비교
2. 찾으면 해당 인덱스 반환
3. 끝까지 찾지 못하면 `-1` 반환

### 자바 예시 코드

```java
public class LinearSearch {
	public static int linearSearch(int[] arr, int target) {

		// 1. 배열의 첫 번째 요소(인덱스 0)부터 마지막 요소까지 순회 시작
		// 'i'는 현재 보고 있는 배열 요소의 위치(인덱스)를 나타냄
		for (int i = 0; i < arr.length; i++) {

			// 2. 현재 인덱스(i)의 배열 값(arr[i])이 찾으려는 값(target)과 같은지 비교
			if (arr[i] == target) {
				// 3. 만약 값이 같다면, 탐색에 성공했으므로 현재 인덱스(i)를 즉시 반환하고 메서드 종료
				return i;
			}
		}

		// 4. 반복문이 끝날 때까지 target 값을 찾지 못했다면
		// 배열 전체를 다 살펴보았다는 의미
		// 찾지 못했음을 나타내는 특정한 값인 -1을 반환
		return -1;
	}
}
```

---

## 3. 버블 정렬 (Bubble Sort)

### 개념
버블 정렬은 인접한 원소를 비교해 큰 값을 뒤로 보내면서 정렬
단순하고 정렬의 기본 개념을 이해하기 좋음
* 시간 복잡도: $\text{O}(n^2)$

#### 동작 과정 예시:
`[5, 3, 8, 4, 2] → [3, 5, 4, 2, 8] → [3, 4, 2, 5, 8] → ...`

```java
public class BubbleSort {
	public static void bubbleSort(int[] arr) {
		// 배열의 길이(전체 요소의 개수)를 저장
		int n = arr.length;

		// 1. 외부 반복문: 정렬을 몇 번 반복할지 결정
		// 배열의 크기(n)만큼 반복하면 정렬이 완료되므로, n-1번 반복
		// 매 반복마다 가장 큰 값이 배열의 맨 뒤로 확정됨 (정렬 범위가 하나씩 줄어듦)
		for (int i = 0; i < n - 1; i++) {

			// 2. 내부 반복문: 인접한 두 요소를 비교하고 교환하는 실제 작업 수행
			// 정렬이 완료된 맨 뒤의 요소들(i개)은 다시 비교할 필요가 없으므로 범위를 줄임
			// 'n - 1 - i'는 아직 정렬되지 않은 부분까지만 순회하겠다는 뜻
			for (int j = 0; j < n - 1 - i; j++) {

				// 3. 인접한 두 요소(arr[j]와 arr[j+1])를 비교
				// 만약 현재 요소(arr[j])가 다음 요소(arr[j+1])보다 크다면, 순서가 잘못된 것
				if (arr[j] > arr[j + 1]) {

					// 4. 두 요소의 위치를 교환 (Swap)
					// 임시 변수(temp)를 사용하여 arr[j] 값을 잠시 보관
					int temp = arr[j];

					// arr[j] 자리에 더 작은 값(arr[j+1])을 넣음
					arr[j] = arr[j + 1];

					// arr[j+1] 자리에 원래 arr[j]였던 큰 값(temp)을 넣음
					arr[j + 1] = temp;
				}
				// 이 과정을 반복하며 가장 큰 값이 배열의 오른쪽 끝으로 이동함
			}
		}
	}
}
```

---

