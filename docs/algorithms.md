# Algorithms

## Overview
알고리즘은 문제를 단계별로 해결하는 절차와 방법
효율적인 설계는 프로그램 성능 개선과 문제 해결에 도움됨

## What is an Algorithm?
알고리즘은 문제 해결을 위한 명확하고 순차적인 단계와 규칙
입력 데이터를 받아 처리하여 원하는 결과를 산출하는 절차
종료 조건이 있고, 효율적이어야 함

---

## 1. 재귀 (Recursion)

### 개념
재귀는 함수가 자기 자신을 호출하는 프로그래밍 기법
복잡한 문제를 같은 유형의 작은 문제로 나누어 해결할 때 유용
분할 정복, DFS, 백트래킹 등 고급 알고리즘의 근본적인 사고방식

### 기본 구조
- 기본 사례: 재귀 종료 조건. 무한 호출 방지 목적
- 재귀 사례: 함수가 자기 자신을 다시 호출하여 문제를 해결하는 부분

### 예시 1: 팩토리얼 (n!)

```java
public class Factorial {
    public static int factorial(int n) {
        if (n == 0) return 1; // 기본 사례 (재귀 종료 조건)
        return n * factorial(n - 1); // 재귀 사례 (자기 자신 호출)
    }
}
```

### 예시 2: 피보나치 수열 (재귀 버전)

```java
public class Fibonacci {
    public static int fib(int n) {
        if (n < 2) return n;  // 기본 사례 (F(0)=0, F(1)=1)
        return fib(n - 1) + fib(n - 2); // 재귀 사례
    }
}
```

### 중요 개념: 스택 메모리 구조
재귀 함수 호출 시, 각 호출은 호출 스택 (Call Stack)에 쌓임
기본 사례에 도달하면 호출이 역순으로 종료되면서 스택에서 해제됨

---

## 2. 선형 탐색 (Linear Search)

### 개념
선형 탐색은 배열의 처음부터 끝까지 원소를 하나씩 순차적으로 비교해 원하는 값을 찾는 가장 단순한 탐색 알고리즘
데이터가 정렬되어 있지 않아도 사용 가능
* 시간 복잡도: $\text{O}(n)$

### 작동 원리
1. 배열 첫 원소부터 목표값을 찾을 때까지 하나씩 비교
2. 찾으면 해당 인덱스 반환
3. 끝까지 찾지 못하면 `-1` 반환

### 자바 예시 코드

```java
public class LinearSearch {
	public static int linearSearch(int[] arr, int target) {

		// 1. 배열의 첫 번째 요소(인덱스 0)부터 마지막 요소까지 순회 시작
		// 'i'는 현재 보고 있는 배열 요소의 위치(인덱스)를 나타냄
		for (int i = 0; i < arr.length; i++) {

			// 2. 현재 인덱스(i)의 배열 값(arr[i])이 찾으려는 값(target)과 같은지 비교
			if (arr[i] == target) {
				// 3. 만약 값이 같다면, 탐색에 성공했으므로 현재 인덱스(i)를 즉시 반환하고 메서드 종료
				return i;
			}
		}

		// 4. 반복문이 끝날 때까지 target 값을 찾지 못했다면
		// 배열 전체를 다 살펴보았다는 의미
		// 찾지 못했음을 나타내는 특정한 값인 -1을 반환
		return -1;
	}
}
```

---

